{"version":3,"file":"110.saito.js","mappings":"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","sources":["webpack://saito/./node_modules/blake3/browser.js","webpack://saito/./node_modules/blake3/dist/wasm/browser/blake3_js_bg.js"],"sourcesContent":["import { provideWasm } from './esm/browser/wasm';\nimport * as wasm from './dist/wasm/browser';\n\nprovideWasm(wasm);\n\nexport * from './esm/browser';\n","import * as wasm from './blake3_js_bg.wasm';\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {Uint8Array} data\n* @param {Uint8Array} out\n*/\nexport function hash(data, out) {\n    try {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(out, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.hash(ptr0, len0, ptr1, len1);\n    } finally {\n        out.set(getUint8Memory0().subarray(ptr1 / 1, ptr1 / 1 + len1));\n        wasm.__wbindgen_free(ptr1, len1 * 1);\n    }\n}\n\n/**\n* @returns {Blake3Hash}\n*/\nexport function create_hasher() {\n    var ret = wasm.create_hasher();\n    return Blake3Hash.__wrap(ret);\n}\n\n/**\n* @param {Uint8Array} key_slice\n* @returns {Blake3Hash}\n*/\nexport function create_keyed(key_slice) {\n    var ptr0 = passArray8ToWasm0(key_slice, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.create_keyed(ptr0, len0);\n    return Blake3Hash.__wrap(ret);\n}\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n/**\n* @param {string} context\n* @returns {Blake3Hash}\n*/\nexport function create_derive(context) {\n    var ptr0 = passStringToWasm0(context, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.create_derive(ptr0, len0);\n    return Blake3Hash.__wrap(ret);\n}\n\nconst u32CvtShim = new Uint32Array(2);\n\nconst uint64CvtShim = new BigUint64Array(u32CvtShim.buffer);\n/**\n*/\nexport class Blake3Hash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Blake3Hash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_blake3hash_free(ptr);\n    }\n    /**\n    * @returns {HashReader}\n    */\n    reader() {\n        var ret = wasm.blake3hash_reader(this.ptr);\n        return HashReader.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} input_bytes\n    */\n    update(input_bytes) {\n        var ptr0 = passArray8ToWasm0(input_bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.blake3hash_update(this.ptr, ptr0, len0);\n    }\n    /**\n    * @param {Uint8Array} out\n    */\n    digest(out) {\n        try {\n            var ptr0 = passArray8ToWasm0(out, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.blake3hash_digest(this.ptr, ptr0, len0);\n        } finally {\n            out.set(getUint8Memory0().subarray(ptr0 / 1, ptr0 / 1 + len0));\n            wasm.__wbindgen_free(ptr0, len0 * 1);\n        }\n    }\n}\n/**\n*/\nexport class HashReader {\n\n    static __wrap(ptr) {\n        const obj = Object.create(HashReader.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_hashreader_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    */\n    fill(bytes) {\n        try {\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.hashreader_fill(this.ptr, ptr0, len0);\n        } finally {\n            bytes.set(getUint8Memory0().subarray(ptr0 / 1, ptr0 / 1 + len0));\n            wasm.__wbindgen_free(ptr0, len0 * 1);\n        }\n    }\n    /**\n    * @param {BigInt} position\n    */\n    set_position(position) {\n        uint64CvtShim[0] = position;\n        const low0 = u32CvtShim[0];\n        const high0 = u32CvtShim[1];\n        wasm.hashreader_set_position(this.ptr, low0, high0);\n    }\n}\n\nexport const __wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n"],"names":["cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","Uint8Array","WASM_VECTOR_LEN","passArray8ToWasm0","arg","malloc","ptr","length","set","hash","data","out","ptr0","len0","ptr1","len1","subarray","create_hasher","ret","Blake3Hash","__wrap","create_keyed","key_slice","cachedTextEncoder","TextEncoder","encodeString","encodeInto","view","buf","encode","read","written","create_derive","context","realloc","undefined","len","mem","offset","code","charCodeAt","slice","passStringToWasm0","u32CvtShim","Uint32Array","uint64CvtShim","BigUint64Array","static","obj","Object","create","prototype","free","this","reader","HashReader","update","input_bytes","digest","fill","bytes","set_position","position","low0","high0","__wbindgen_throw","arg0","arg1","Error"],"sourceRoot":""}